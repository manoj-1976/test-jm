import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/react-simple-animate/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-simple-animate/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var DEFAULT_DURATION = 0.3;
    var DEFAULT_EASE_TYPE = "linear";
    var DEFAULT_DIRECTION = "normal";
    var DEFAULT_FILLMODE = "none";
    var RUNNING = "running";
    var PAUSED = "paused";
    var ALL = "all";
    var calculateTotalDuration = ({ duration = DEFAULT_DURATION, delay = 0, overlay = 0 }) => duration + delay - overlay || 0;
    var isUndefined = (val) => val === void 0;
    function getSequenceId(sequenceIndex, sequenceId, defaultValue) {
      if (isUndefined(sequenceId) && isUndefined(sequenceIndex)) {
        return defaultValue || 0;
      }
      if (sequenceIndex && sequenceIndex >= 0) {
        return sequenceIndex;
      }
      if (sequenceId) {
        return sequenceId;
      }
      return 0;
    }
    var AnimateContext = React__namespace.createContext({
      animationStates: {},
      register: () => {
      }
    });
    function AnimateGroup({ play, sequences = [], children }) {
      const [animationStates, setAnimationStates] = React__namespace.useState({});
      const animationsRef = React__namespace.useRef({});
      const register = React__namespace.useCallback((data) => {
        const { sequenceIndex, sequenceId } = data;
        if (!isUndefined(sequenceId) || !isUndefined(sequenceIndex)) {
          animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data;
        }
      }, []);
      React__namespace.useEffect(() => {
        const sequencesToAnimate = Array.isArray(sequences) && sequences.length ? sequences : Object.values(animationsRef.current);
        const localAnimationState = {};
        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, { sequenceId, sequenceIndex, duration = DEFAULT_DURATION, delay, overlay }, currentIndex) => {
          const id = getSequenceId(sequenceIndex, sequenceId, currentIndex);
          const currentTotalDuration = calculateTotalDuration({
            duration,
            delay,
            overlay
          });
          const totalDuration = currentTotalDuration + previous;
          localAnimationState[id] = {
            play,
            pause: !play,
            delay: (delay || 0) + previous,
            controlled: true
          };
          return totalDuration;
        }, 0);
        setAnimationStates(localAnimationState);
      }, [play]);
      return React__namespace.createElement(AnimateContext.Provider, { value: { animationStates, register } }, children);
    }
    var secToMs = (ms) => (ms || 0) * 1e3;
    function Animate(props) {
      const { play, children, render, start, end, complete = "", onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, sequenceId, sequenceIndex } = props;
      const onCompleteTimeRef = React__namespace.useRef();
      const [style, setStyle] = React__namespace.useState(start || {});
      const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);
      const id = getSequenceId(sequenceIndex, sequenceId);
      React__namespace.useEffect(() => {
        if (!isUndefined(sequenceIndex) && sequenceIndex >= 0 || sequenceId) {
          register(props);
        }
      }, []);
      React__namespace.useEffect(() => {
        const animationState = animationStates[id] || {};
        setStyle({
          ...play || animationState.play ? end : start,
          transition: `${ALL} ${duration}s ${easeType} ${animationState.delay || delay}s`
        });
        if (play && (complete || onComplete)) {
          onCompleteTimeRef.current = setTimeout(() => {
            complete && setStyle(complete);
            onComplete && onComplete();
          }, secToMs((animationState.delay || delay) + duration));
        }
        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
      }, [
        id,
        animationStates,
        play,
        duration,
        easeType,
        delay,
        onComplete,
        start,
        end,
        complete
      ]);
      return render ? render({ style }) : React__namespace.createElement("div", { style }, children);
    }
    var camelCaseToDash = (camelCase) => camelCase ? camelCase.replace(/[A-Z]/g, (c) => `-${c.toLowerCase()}`) : "";
    var generateKeyframes = (keyframes) => {
      const animationLength = keyframes.length;
      return keyframes.reduce((previous, keyframe, currentIndex) => {
        const keyframePercentage = parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex;
        if (typeof keyframe === "string") {
          return `${previous} ${keyframePercentage}% {${keyframe}}`;
        }
        const keys = Object.keys(keyframe);
        if (keys.length && isNaN(+keys[0])) {
          const keyframeContent = keys.reduce((acc, key) => `${acc} ${camelCaseToDash(key)}: ${keyframe[key]};`, "");
          return `${previous} ${keyframePercentage}% {${keyframeContent}}`;
        }
        return `${previous} ${keys[0]}% {${keyframe[keys[0]]}}`;
      }, "");
    };
    function createStyle({ keyframes, animationName }) {
      return `@keyframes ${animationName} {${generateKeyframes(keyframes)}}`;
    }
    function createTag({ keyframes, animationName }) {
      var _a, _b, _c, _d;
      let styleTag = document.querySelector("style[data-id=rsi]");
      if (!styleTag) {
        styleTag = document.createElement("style");
        styleTag.setAttribute("data-id", "rsi");
        document.head.appendChild(styleTag);
      }
      const index = (_c = (_b = (_a = styleTag.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
      try {
        (_d = styleTag.sheet) === null || _d === void 0 ? void 0 : _d.insertRule(createStyle({
          keyframes,
          animationName
        }), index);
      } catch (e) {
        console.error("react simple animate, error found during insert style ", e);
      }
      return {
        styleTag,
        index
      };
    }
    var deleteRules = (sheet, deleteName) => {
      if (!sheet) {
        return;
      }
      const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);
      if (index >= 0) {
        sheet.deleteRule(index);
      }
    };
    var createRandomName = () => `RSI-${Math.random().toString(36).substr(2, 9)}`;
    var getPlayState = (pause) => pause ? PAUSED : RUNNING;
    function AnimateKeyframes(props) {
      const { children, play = false, pause = false, render, duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, sequenceIndex, keyframes, sequenceId } = props;
      let pauseValue;
      const animationNameRef = React__namespace.useRef({
        forward: "",
        reverse: ""
      });
      const controlled = React__namespace.useRef(false);
      const styleTagRef = React__namespace.useRef({
        forward: null,
        reverse: null
      });
      const id = getSequenceId(sequenceIndex, sequenceId);
      const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);
      const animateState = animationStates[id] || {};
      const [, forceUpdate] = React__namespace.useState(false);
      React__namespace.useEffect(() => {
        const styleTag = styleTagRef.current;
        const animationName = animationNameRef.current;
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
          animationName: animationNameRef.current.forward,
          keyframes
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
          animationName: animationNameRef.current.reverse,
          keyframes: keyframes.reverse()
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        if (play) {
          forceUpdate(true);
        }
        return () => {
          var _a, _b;
          deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);
          deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);
        };
      }, []);
      if (animateState.controlled && !controlled.current) {
        pauseValue = animateState.pause;
        if (!animateState.pause) {
          controlled.current = true;
        }
      } else {
        pauseValue = pause;
      }
      const style = {
        animation: `${duration}s ${easeType} ${animateState.delay || delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(pauseValue)} ${((animateState.controlled ? animateState.play : play) ? animationNameRef.current.forward : animationNameRef.current.reverse) || ""}`
      };
      return render ? render({ style }) : React__namespace.createElement("div", { style: style || {} }, children);
    }
    function useAnimate(props) {
      const { start, end, complete, onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE } = props;
      const transition = React__namespace.useMemo(() => `${ALL} ${duration}s ${easeType} ${delay}s`, [duration, easeType, delay]);
      const [animate, setAnimate] = React__namespace.useState({
        isPlaying: false,
        style: { ...start, transition }
      });
      const { isPlaying, style } = animate;
      const onCompleteTimeRef = React__namespace.useRef();
      React__namespace.useEffect(() => {
        if ((onComplete || complete) && isPlaying) {
          onCompleteTimeRef.current = setTimeout(() => {
            if (onComplete) {
              onComplete();
            }
            if (complete) {
              setAnimate((animate2) => ({
                ...animate2,
                style: complete
              }));
            }
          }, secToMs(delay + duration));
        }
        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
      }, [animate, complete, delay, duration, isPlaying, onComplete]);
      return {
        isPlaying,
        style,
        play: React__namespace.useCallback((isPlaying2) => {
          setAnimate((animate2) => ({
            ...animate2,
            style: {
              ...isPlaying2 ? end : start,
              transition
            },
            isPlaying: isPlaying2
          }));
        }, [end, start, transition])
      };
    }
    function useAnimateKeyframes(props) {
      const { duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, keyframes } = props;
      const animationNameRef = React__namespace.useRef({
        forward: "",
        reverse: ""
      });
      const styleTagRef = React__namespace.useRef({
        forward: null,
        reverse: null
      });
      const { register } = React__namespace.useContext(AnimateContext);
      const [isPlaying, setIsPlaying] = React__namespace.useState(null);
      const [isPaused, setIsPaused] = React__namespace.useState(false);
      React__namespace.useEffect(() => {
        const styleTag = styleTagRef.current;
        const animationName = animationNameRef.current;
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
          animationName: animationNameRef.current.forward,
          keyframes
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
          animationName: animationNameRef.current.reverse,
          keyframes: keyframes.reverse()
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        return () => {
          var _a, _b;
          deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);
          deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);
        };
      }, []);
      const style = {
        animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(isPaused)} ${isPlaying === null ? "" : isPlaying ? animationNameRef.current.forward : animationNameRef.current.reverse}`
      };
      return {
        style,
        play: setIsPlaying,
        pause: setIsPaused,
        isPlaying: !!isPlaying
      };
    }
    function createArrayWithNumbers(length) {
      return Array.from({ length }, () => null);
    }
    function useAnimateGroup(props) {
      const { sequences = [] } = props;
      const defaultArray = createArrayWithNumbers(sequences.length).map((_, index) => props.sequences[index].start);
      const [styles, setStyles] = React__namespace.useState(defaultArray);
      const [isPlaying, setPlaying] = React__namespace.useState(false);
      const animationNamesRef = React__namespace.useRef([]);
      const styleTagRef = React__namespace.useRef([]);
      React__namespace.useEffect(() => {
        sequences.forEach(({ keyframes }, i) => {
          if (!Array.isArray(keyframes)) {
            return;
          }
          if (!animationNamesRef.current[i]) {
            animationNamesRef.current[i] = {};
            styleTagRef.current[i] = {};
          }
          animationNamesRef.current[i].forward = createRandomName();
          let result = createTag({
            animationName: animationNamesRef.current[i].forward,
            keyframes
          });
          styleTagRef.current[i].forward = result.styleTag;
          animationNamesRef.current[i].reverse = createRandomName();
          result = createTag({
            animationName: animationNamesRef.current[i].reverse,
            keyframes: keyframes.reverse()
          });
          styleTagRef.current[i].reverse = result.styleTag;
        });
        const styleTags = styleTagRef.current;
        const animationNames = animationNamesRef.current;
        return () => Object.values(animationNames).forEach(({ forward, reverse }, i) => {
          var _a, _b;
          deleteRules((_a = styleTags[i].forward) === null || _a === void 0 ? void 0 : _a.sheet, forward);
          deleteRules((_b = styleTags[i].reverse) === null || _b === void 0 ? void 0 : _b.sheet, reverse);
        });
      }, []);
      const play = React__namespace.useCallback((isPlay) => {
        let totalDuration = 0;
        const animationRefWithOrder = isPlay ? animationNamesRef.current : [...animationNamesRef.current].reverse();
        const styles2 = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {
          const { duration = DEFAULT_DURATION, delay = 0, overlay, keyframes, iterationCount = 1, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, end = {}, start = {} } = current;
          const delayDuration = currentIndex === 0 ? delay : totalDuration;
          const transition = `${ALL} ${duration}s ${easeType} ${delayDuration}s`;
          totalDuration = calculateTotalDuration({ duration, delay, overlay }) + totalDuration;
          return keyframes ? {
            animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} ${RUNNING} ${isPlay ? animationRefWithOrder[currentIndex].forward : animationRefWithOrder[currentIndex].reverse}`
          } : {
            ...isPlay ? end : start,
            transition
          };
        });
        setStyles(isPlay ? styles2 : [...styles2].reverse());
        setPlaying(isPlay);
      }, []);
      return { styles, play, isPlaying };
    }
    exports.Animate = Animate;
    exports.AnimateGroup = AnimateGroup;
    exports.AnimateKeyframes = AnimateKeyframes;
    exports.useAnimate = useAnimate;
    exports.useAnimateGroup = useAnimateGroup;
    exports.useAnimateKeyframes = useAnimateKeyframes;
  }
});

// node_modules/react-flip-numbers/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-flip-numbers/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var React = _interopDefault(require_react());
    var reactSimpleAnimate = require_dist();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        keys.push.apply(keys, Object.getOwnPropertySymbols(object));
      }
      if (enumerableOnly) keys = keys.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(source, true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(source).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    var commonAnimateStyle = {
      position: "absolute",
      height: "100%",
      transformStyle: "preserve-3d"
    };
    var easeType = "cubic-bezier(0.19, 1, 0.22, 1)";
    var revolutionDegrees = 360;
    var resetRouteCounter = 1e3;
    var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    var rotateDegreePerNumber = 36;
    var calculateDegrees = function calculateDegrees2(rotateCounter, activeNumber) {
      var animateDegree = numbers.findIndex(function(v) {
        return v === activeNumber;
      }) * rotateDegreePerNumber;
      var amountDegree = rotateCounter * revolutionDegrees;
      return _objectSpread2({}, activeNumber === 0 ? {
        rotateCounter: rotateCounter > resetRouteCounter ? 0 : rotateCounter + 1
      } : null, {
        degree: amountDegree - animateDegree
      });
    };
    var FlipNumber = function(_React$Component) {
      _inherits(FlipNumber2, _React$Component);
      function FlipNumber2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, FlipNumber2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FlipNumber2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_this), "state", {
          degree: 0,
          rotateCounter: 0
          // eslint-disable-line react/no-unused-state
        });
        _defineProperty(_assertThisInitialized(_this), "updateNumber", function() {
          _this.setState(function(_ref) {
            var rotateCounter = _ref.rotateCounter;
            return calculateDegrees(rotateCounter, _this.props.activeNumber);
          });
        });
        return _this;
      }
      _createClass(FlipNumber2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;
          this.updateNumberTimeout = setTimeout(function() {
            return _this2.updateNumber();
          }, 50 * this.props.position);
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps) {
          return nextProps.className !== this.props.className || nextProps.activeNumber !== this.props.activeNumber || nextProps.height !== this.props.height || nextProps.width !== this.props.width || this.state.degree === 0 || nextProps.play !== this.props.play;
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          clearTimeout(this.updateNumberTimeout);
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props, activeNumber = _this$props.activeNumber, height = _this$props.height, color = _this$props.color, background = _this$props.background, width = _this$props.width, perspective = _this$props.perspective, duration = _this$props.duration, play = _this$props.play, delay = _this$props.delay, length = _this$props.length, position = _this$props.position, _this$props$numberSty = _this$props.numberStyle, numberStyle = _this$props$numberSty === void 0 ? {} : _this$props$numberSty, className = _this$props.className;
          var degree = this.state.degree;
          var viewPortSize = {
            width: "".concat(width, "px"),
            height: "".concat(height + 3, "px")
          };
          var halfElementHeight = height / 2;
          var translateZ = halfElementHeight + height;
          return React.createElement("span", {
            style: _objectSpread2({}, viewPortSize, {
              perspective,
              overflow: "hidden",
              display: "inline-block",
              textAlign: "left",
              height
            }),
            className,
            "aria-hidden": true
          }, React.createElement(reactSimpleAnimate.Animate, _extends({
            tag: "span",
            play,
            start: _objectSpread2({}, commonAnimateStyle),
            end: _objectSpread2({}, commonAnimateStyle, {
              transform: "rotateX(".concat(degree, "deg)")
            })
          }, {
            easeType,
            duration,
            delay
          }, {
            render: function render2(_ref2) {
              var style = _ref2.style;
              return React.createElement("span", {
                style
              }, numbers.map(function(n, i) {
                return React.createElement("span", {
                  style: _objectSpread2({}, viewPortSize, {
                    height,
                    lineHeight: "".concat(height, "px"),
                    fontSize: "".concat(height - 1, "px"),
                    position: "absolute",
                    display: "flex",
                    justifyContent: "center",
                    alignItems: "center",
                    textAlign: "center",
                    WebkitFontSmoothing: "antialiased",
                    color,
                    background,
                    backfaceVisibility: "hidden",
                    WebkitBackfaceVisibility: "hidden",
                    transform: "rotateX(".concat(rotateDegreePerNumber * i, "deg) translateZ(").concat(translateZ, "px)")
                  }, numberStyle),
                  key: "".concat(rotateDegreePerNumber * i)
                }, n);
              }));
            }
          })), React.createElement("span", {
            data: length - position,
            style: _objectSpread2({}, viewPortSize, {
              height,
              lineHeight: "".concat(height, "px"),
              fontSize: "".concat(height - 1, "px"),
              left: "".concat(length - position > 4 ? 0.25 : 0, "px"),
              // hacky fix for weird misalignment in Chrome.
              position: "absolute",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              textAlign: "center",
              WebkitFontSmoothing: "antialiased",
              color,
              background,
              transform: "rotateX(0deg) translateZ(".concat(translateZ, "px)"),
              visibility: "hidden"
            }, numberStyle)
          }, activeNumber));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(_ref3, _ref4) {
          var activeNumber = _ref3.activeNumber;
          var rotateCounter = _ref4.rotateCounter;
          return calculateDegrees(rotateCounter, activeNumber);
        }
      }]);
      return FlipNumber2;
    }(React.Component);
    var FlipNumbers = function(_React$Component) {
      _inherits(FlipNumbers2, _React$Component);
      function FlipNumbers2() {
        _classCallCheck(this, FlipNumbers2);
        return _possibleConstructorReturn(this, _getPrototypeOf(FlipNumbers2).apply(this, arguments));
      }
      _createClass(FlipNumbers2, [{
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps) {
          return nextProps.nonNumberClassName !== this.props.nonNumberClassName || nextProps.numberClassName !== this.props.numberClassName || nextProps.numbers !== this.props.numbers || nextProps.height !== this.props.height || nextProps.width !== this.props.width || nextProps.duration !== this.props.duration || nextProps.delay !== this.props.delay || nextProps.play !== this.props.play;
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props, numbers2 = _this$props.numbers, nonNumberStyle = _this$props.nonNumberStyle, numberStyle = _this$props.numberStyle, numberClassName = _this$props.numberClassName, nonNumberClassName = _this$props.nonNumberClassName, height = _this$props.height, width = _this$props.width, color = _this$props.color, background = _this$props.background, perspective = _this$props.perspective, duration = _this$props.duration, animate = _this$props.animate, play = _this$props.play, delay = _this$props.delay;
          var numberCounter = 0;
          return React.createElement("section", {
            style: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            },
            "aria-label": numbers2
          }, Array.from(numbers2).map(function(n, key) {
            var nonNumber = React.createElement("span", {
              "aria-hidden": true,
              style: nonNumberStyle,
              className: nonNumberClassName,
              key: numberCounter
            }, n);
            if (animate) {
              numberCounter += 1;
              return !Number.isNaN(parseInt(n, 10)) ? React.createElement(FlipNumber, _extends({
                key,
                height,
                width,
                color,
                background,
                perspective,
                duration,
                play,
                delay,
                numberStyle
              }, {
                position: numberCounter,
                length: numbers2.length,
                activeNumber: parseInt(n, 10),
                className: numberClassName
              })) : nonNumber;
            }
            return !Number.isNaN(parseInt(n, 10)) ? React.createElement("span", {
              "aria-hidden": true,
              style: nonNumberStyle || {
                padding: 0
              },
              key: numberCounter
            }, n) : nonNumber;
          }));
        }
      }]);
      return FlipNumbers2;
    }(React.Component);
    _defineProperty(FlipNumbers, "defaultProps", {
      perspective: 500,
      duration: 0.3,
      animate: true,
      play: false,
      delay: 0,
      nonNumberStyle: {},
      numberStyle: {}
    });
    exports.FlipNumber = FlipNumber;
    exports.default = FlipNumbers;
  }
});
export default require_lib();
//# sourceMappingURL=react-flip-numbers.js.map
